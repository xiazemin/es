**倒排索引**

  


![](https://pic2.zhimg.com/80/v2-c884f991f01dc87af7bfeaff6aec5d79_hd.jpg)

倒排索引中记录的信息主要有：

* 文档编号：segment内部文档编号从0开始，最大值为int最大值，文档写入之后会分配这样一个顺序号
 
* 字典：字段内容经过分词、归一化、还原词根等操作之后，得到的所有单词
* 单词出现位置：
 
  ▫分词字段默认开启，提供对于短语查询的支持
 
  ▫对于非常常见的词，例如the，位置信息可能占用很大空间，短语查询需要读取的数据量很大，查询速度慢
* 单词出现次数：单词在文档中出现的次数，作为评分的依据
* 单词结束字符到开始字符的偏移量：记录在文档中开始与结束字符的偏移量，提供高亮使用，默认是禁用的
* 规范因子：对字段长度进行规范化的因子，给予较短字段更多权重

倒排索引的查找过程本质上是通过单词找对应的文档列表的过程，因此倒排索引中字典的设计决定了倒排索引的查询速度，字典主要包括前缀索引（.tip文件）和后缀索引（.tim）文件。

**字典前缀索引（.tip文件）**

一个合格的词典结构一般有以下特点：

-查询速度快 -内存占用小 -内存+磁盘相结合

  


![](https://pic4.zhimg.com/80/v2-353d686402b046a2c9c7caf3d3f359fb_hd.jpg)

Lucene采用的前缀索引数据结构为FST，它的优点有：

词查找复杂度为O\(len\(str\)\)

* 共享前缀、节省空间、内存占用率低，压缩率高，模糊查询支持好
* 内存存放前缀索引，磁盘存放后缀词块
* 缺点：结构复杂、输入要求有序、更新不易

**字典后缀（.tim文件）**

后缀词块主要保存了单词后缀，以及对应的文档列表的位置。

**文档列表（.doc文件）**

![](https://pic4.zhimg.com/80/v2-f23f7c0fa7506b47d70a2ce128229a2f_hd.jpg)

lucene对文档列表存储进行了很好的压缩，来保证缓存友好：

* 差分压缩：每个ID只记录跟前面的ID的差值
* 每256个ID放入一个block中
* block的头信息存放block中每个ID占用的bit位数，因为经过上面的差分压缩之后，文档列表中的文档ID都变得不大，占用的bit位数变少

上图经过压缩之后将6个数字从原先的24bytes压缩到7bytes。

文档列表的合并

![](https://pic4.zhimg.com/80/v2-4cd887a54c0e6777396b3feb6ee27e9f_hd.jpg)

ES的一个重要的查询场景是bool查询，类似于mysql中的and操作，需要将两个条件对应的文档列表进行合并。为了加快文档列表的合并，lucene底层采用了跳表的数据结构，合并过程中，优先遍历较短的链表，去较长的列表中进行查询，如果存在，则该文档符合条件。  


![](https://pic1.zhimg.com/80/v2-178771a85ea61c35b441cef8d823c3d4_hd.jpg)

**倒排索引的查询过程**

![](https://pic3.zhimg.com/80/v2-160c3d269fcc33f332ca8a9813daf84a_hd.jpg)

* 内存加载tip文件，通过FST匹配前缀找到后缀词块位置
* 根据词块位置，读取磁盘中tim文件中后缀块并找到后缀和相应的倒排表位置信息
* 根据倒排表位置去doc文件中加载倒排表
* 借助跳表结构，对多个文档列表进行合并

**filter查询的缓存**

对于filter过滤查询的结果，ES会进行缓存，缓存采用的数据结构是RoaringBitmap，在match查询中配合filter能有效加快查询速度。

* 普通bitset的缺点：内存占用大，RoaringBitmap有很好的压缩特性
* 分桶：解决文档列表稀疏的情况下，过多的0占用内存，每65536个docid分到一个桶，桶内只记录docid%65536
* 桶内压缩：4096作为分界点，小余这个值用short数组，大于这个值用bitset，每个short占两字节，4096个short占用65536bit，所以超过4096个文档id之后，是bitset更节省空间。

![](https://pic1.zhimg.com/80/v2-a778a4a476d675485b7f86d334a83314_hd.jpg)

**DocValues（正排索引&列式存储）**

![](https://pic1.zhimg.com/80/v2-ef32ff57f914abbf9723fa821d473d60_hd.jpg)

倒排索引保存的是词项到文档的映射，也就是词项存在于哪些文档中，DocValues保存的是文档到词项的映射，也就是文档中有哪些词项。

**相关设置**

keyword字段默认开启

**ES6.0（lucene7.0）之前**

DocValues采用的数据结构是bitset，bitset对于稀疏数据的支持不好：

* 对于稀疏的字段来说，绝大部分的空间都被0填充，浪费空间
* 由于字段的值之间插入了0，可能本来连续的值被0间隔开来了，不利于数据的压缩
* 空间被一堆0占用了，缓存中缓存的有效数据减少，查询效率也会降低

查询逻辑很简单，类似于数组通过下标进行索引，因为每个value都是固定长度，所以读取文档id为N的value直接从N\*固定长度位置开始读取固定长度即可。

![](https://pic2.zhimg.com/80/v2-ce26ec51cbfd3987b47cb77918277185_hd.jpg)

**ES6.0（lucene7.0）**

* docid的存储的通过分片加快映射到value的查询速度
* value存储的时候不再给空的值分配空间

因为value存储的时候，空值不再分配空间，所以查询的时候不能通过上述通过文档id直接映射到在bitset中的偏移量来获取对应的value，需要通过获取docid的位置来找到对应的value的位置。

所以对于DocValues的查找，关键在于DocIDSet中ID的查找，如果按照简单的链表的查找逻辑，那么DocID的查找速度将会很慢。lucene7借用了RoaringBitmap的分片的思想来加快DocIDSet的查找速度：

![](https://pic1.zhimg.com/80/v2-09bfe900ffa51ff653c95a92acb7e78c_hd.jpg)

* 分片容量为2的16次方，最多可以存储65536个docid
* 分片包含的信息：
 
  ▫分片ID
 
  ▫存储的docid的个数（值不为空的DocIDSet）
 
  ▫DocIDSet明细，或者标记分片类型（ALL或者NONE）
* 根据分片的容量，将分片分为四种不同的类型，不同类型的查找逻辑不通：
 
  ▫ALL：该分片内没有不存在值的DocID
 
  ▫NONE：该分片内所有的DocID都不存在值
 
  ▫SPARSE：该分片内存在值的DocID的个数不超过4096，DocIDSet以short数组的形式存储，查找的时候，遍历数组，找到对应的ID的位置
 
  ▫DENSE：该分片内存在值的DocID的个数超过4096，DocIDSet以bitset的形式存储，ID的偏移量也就是在该分片中的位置

最终DocIDSet的查找逻辑为：

* 计算DocID/65536，得到所在的分片N
* 计算前面N-1个分片的DocID的总数
* 找到DocID在分片N内部的位置，从而找到所在位置之前的DocID个数M
* 找到N+M位置的value即为该DocID对应的value



