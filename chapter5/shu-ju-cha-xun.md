**数据查询**

**查询过程（query then fetch）**

* 协调节点将请求发送给对应分片
* 分片查询，返回from+size数量的文档对应的id以及每个id的得分
* 汇总所有节点的结果，按照得分获取指定区间的文档id
* 根据查询需求，像对应分片发送多个get请求，获取文档的信息
* 返回给客户端

get查询更快

默认根据id对文档进行路由，所以指定id的查询可以定位到文档所在的分片，只对某个分片进行查询即可。当然非get查询，只要写入和查询的时候指定routing，同样可以达到该效果。

主分片与副本分片

ES的分片有主备之分，但是对于查询来说，主备分片的地位完全相同，平等的接收查询请求。这里涉及到一个请求的负载均衡策略，6.0之前采用的是轮询的策略，但是这种策略存在不足，轮询方案只能保证查询数据量在主备分片是均衡的，但是不能保证查询压力在主备分片上是均衡的，可能出现慢查询都路由到了主分片上，导致主分片所在的机器压力过大，影响了整个集群对外提供服务的能力。

新版本中优化了该策略，采用了基于负载的请求路由，基于队列的耗费时间自动调节队列长度，负载高的节点的队列长度将减少，让其他节点分摊更多的压力，搜索和索引都将基于这种机制。

**get查询的实时性**

ES数据写入之后，要经过一个refresh操作之后，才能够创建索引，进行查询。但是get查询很特殊，数据实时可查。

ES5.0之前translog可以提供实时的CRUD，get查询会首先检查translog中有没有最新的修改，然后再尝试去segment中对id进行查找。5.0之后，为了减少translog设计的负责性以便于再其他更重要的方面对translog进行优化，所以取消了translog的实时查询功能。

get查询的实时性，通过每次get查询的时候，如果发现该id还在内存中没有创建索引，那么首先会触发refresh操作，来让id可查。

**查询方式**

两种查询上下文：

* query：例如全文检索，返回的是文档匹配搜索条件的相关性，常用api：match
* filter：例如时间区间的限定，回答的是是否，要么是，要么不是，不存在相似程度的概念，常用api：term、range

过滤（filter）的目标是减少那些需要进行评分查询（scoring queries）的文档数量。

分析器\(analyzer\)

当索引一个文档时，它的全文域被分析成词条以用来创建倒排索引。当进行分词字段的搜索的时候，同样需要将查询字符串通过相同的分析过程，以保证搜索的词条格式与索引中的词条格式一致。当查询一个不分词字段时，不会分析查询字符串，而是搜索指定的精确值。

可以通过下面的命令查看分词结果：

```
GET /_analyze
{
  "analyzer": "standard",
  "text": "Text to analyze"
}
```

相关性

默认情况下，返回结果是按相关性倒序排列的。每个文档都有相关性评分，用一个正浮点数字段score来表示。score的评分越高，相关性越高。

ES的相似度算法被定义为检索词频率/反向文档频率\(TF/IDF\)，包括以下内容：

* 检索词频率：检索词在该字段出现的频率，出现频率越高，相关性也越高。字段中出现过5次要比只出现过1次的相关性高。
* 反向文档频率：每个检索词在索引中出现的频率，频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。
* 字段长度准则：字段的长度是多少，长度越长，相关性越低。 检索词出现在一个短的title要比同样的词出现在一个长的content字段权重更大。

查询的时候可以通过添加?explain参数，查看上述各个算法的评分结果。

